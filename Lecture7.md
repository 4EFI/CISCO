# Транспортный уровень

## TCP (Transmission Control Protocol)

Главный протокол. Протокол позволяет управлять передачей: регулировать скорость, возможность гарантировать доставку.

Изобразим заголовок TCP сегмента (4-х байтными словами).

<p style="text-align: left"><img src=res/7_1.png width="800px"/></p>

* SN - Номер первого байта в нашем сегменте
* ACK - Номер подтверждения, до какого момента данные были получены. С какого байта ожидаем следующие данные
* DataOffset - Откуда начинаются данные (TCP заголовок может иметь переменную длину)
* Битовые флаги:
    * URG - Важность, передаются ли важные данные
    * ACK - нужно ли обращать на ACK Number
    * PSH - Принятые данные нужно как можно быстрее передать приложению и не хранить в буфере
    * RST - Завершение соединения
    * SYN - Теперь SN имеет значение (только в момент установления соединения)

Как происходи соединение в TCP?

## Классический TCP

Протокол ориентированный на установлении соединения. Должны сначала установить соединение и только потом передавать данные. 

Тройное рукопожатие установления соединения:

* (A -> B) Сперва отсылаем сегмент с выставленным флагом ```SYN``` (Посмотри на поле SN и запомни мои номера, я начинаю передачу отсюда) 
* (B -> A) ```SYN``` и ```ACK``` (Посмотри на мою последовательность, я буду нумеровать данные так. Посмотри на поле ACK, указание на номер байта, который B ожидает получить, до этого момента точно все получено)
* (A -> B) Выставленный флаг ```ACK``` (Я увидел твой SN, понял, что у тебя отсчет с такого номера)

<p style="text-align: left"><img src=res/7_2.png width="400px"/></p>

!!! Данные начинаются с n. Пусть данные разером d. Тогда отправляем ```n + d + 1```. Ожидаем данные с этого байта.

TCP соединение установилось, начинаем передавать данные.

### Скользящее окно

Данные делим на сегменты. Отправили ```n``` байт и ждем ответ ```n + 1```. И так далее. 

<p style="text-align: left"><img src=res/7_3.png width="500px"/></p>

Есть проблема простаивания канала. Ждем пока данные были получены и только потом продолжаем отправку. TCP предлагает скользящее окно. 

Давайте будем отправлять не по одному сегменту, а сразу несколько. Отправляем все то, что попало в окно и только потом ждем подтверждение. 

<p style="text-align: left"><img src=res/7_4.png width="500px"/></p>

Пока отправляем сегменты, нам может прийти подтверждение на ранее отправленные сегменты, тогда двигаем окно.

#### Сегмент потерялся

Предо=положим, что 3-ий сегмент потерялся. При отправке мы запускаем таймеры. Когда истекает таймер, если мы не получили ответ, то второй раз отправляем сегмент и запускаем таймер заново.

На принимающей стороне выделяется буфер в который эти сегменты складываем: 

<p style="text-align: left"><img src=res/7_5.png width="500px"/></p>

!!! 3 для простоты понимания, на самом деле это номера байтов.

Не может подтвердить дальше, пока есть разрыв.


TCP двунаправленный протокол. Сторона говорит соседу, какой размер окна использовать. Сторона может сама решить, какое окно использовать, но ```только меньше``` (У стороны B может быть терабайтная скорость, а у A только мегабайтная, тогда A устанавливает маленькое окно).

Сторона B может выставить ```нулевой размер окна``` - это значит, стоп, мне нужно обработать данные. 

Если данные успешно передаются, то окно увеличивается, в случае разрыва оно сбрасывается, тогда мы можем видеть следующий график ```пила``` (**TCP Slow Start**)

<p style="text-align: left"><img src=res/7_6.png width="500px"/></p>


## Способы оптимизации

* Задержанное подтверждение (Delay ACK). Принимающая сторона, если нет пользовательских данных для отправки, какое-то время будет задерживать отправку пустых сегментов только для подтверждения. Если данные для отправки есть, то шлем данные и выставляем ACK.
* Алгоритм Нейгла - чуть-чуть задерживаем отправку данных, если данные маленькие. Подождем еще немного данных.


## Современный TCP

Как выбирается размер сегмента:

* В IP протоколе выставляем флаг DF (Do not Fragment), если пакет не пролез по MTU, то отсылаем ICMP сигнал. Уменьшаем размер сегмента
* Используем поле опций, а именно MSS (Max Segment Size). Роутер может вмешаться в четвертый уровень и изменить MSS значение

