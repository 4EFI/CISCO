# Оптимизации TCP (продолжение)

Использование опции ```MSS``` (Maximum Segment Size). 

Также допустимы опции ```SACK/NACK```. Подтвердить данные полностью, без перерывов:
* ```Selective ACK``` указывает какие данные пришли (пришли данные до n1 и начиная с n2)
* ```Negative ACK``` наоборот, какие данные не дошли

Опция ```ScalingFactor``` = n. Это некоторое число, которое показывает, во сколько раз нужно увеличить окно, чтобы получить реальное окно:
```
2^n * WindowSize
```

```FastRetransmission```. Получаем, получаем данные. Что-то не дошло. Опять продолжаем получать. Три раза подряд шлем три пустых сегмента подтверждения. **Сразу не выжидая timeout** (позволяет ускорить переотправку):

<p style="text-align: left"><img src=res/8_1.png width="500px"/></p>

Еще одна оптимизация. Не будем при потерях уменьшать окно до минимума.

<p style="text-align: left"><img src=res/8_2.png width="500px"/></p>

## Установление соединения

Как мы помним, соединение устанавливается путем тройного рукопожатия. 

В чем проблема. Может быть атка ```SYN Flooding```. Сервер будет создавать множество сокетов при каждой попытке подключиться и будет значительно замедляться.

### SYN Cookie

Когда сервер понимает, что его атакуют (значительное увеличивается скорость коннекций, так и остаются в полуоткрытом состоянии). 

Сервер получает SYN, НО не создает никаких дополнительных вспомогательных структур, не резервирует память, не держит это полуоткрытое соединение. Он отвечает SYN,ACK, ```НО``` со стороны сервера можно особым образом сгенерировать SN, используя IP-адрес, порт и тд. Посчитать хеш, представить этот хеш в виде 32 битного SN и отправить, а затем забыть это соединение и очистить память.

Если клиент был настоящий? Он присылает ACK. Из ACK вычитаем 1. Считаем заново хеш и если он совпадает с посчитанным, то на этом моменте создаем всю инфраструктуру. 

#### TFO (TCP Fast Open)

Есть еще одно улучшение. Приложению установило TCP соединение с сервером, разорвала. Потом понадобилось еще раз установить соединение. 

При соединение, вместе в SYN запрашиваем Request Cookie. Сервер нам его высылает и мы его запоминаем.

При повторном соединении, узел A отправляет SYN + Cookie + Data (сообщаем серверу, что я с тобой уже общался).


# Протокол DHCP (Dynamic Host Configuration Protocol)

Раньше настраивали IP-адреса и другие сетевые параметры вручную (на телефонах, принтерах, компьютерах и тд). На серверах пытаются вручную настраивать.

Как правило выделяют обмен 4-мя сообщениями (в DHCP сообщений больше, но мы опишем первые 4) DORA:
* Discover - отправляет клиент широковещательно. Пытается найти сервер
* Offer - Сервер отправляет сообщение, вот тебе IP-параметры
* Request - Клиент хочет подтвердить использовать этих параметров
* Ack - Сервер отправляет подтверждение

Все параметры отдаются в виде опций. Клиент должен ее запросить. 

Вот еще сообщения:
* Release - Сообщение от клиента о прекращении использования данного адреса
* Negative ACK - Клиент запрашивает право на использование определенного IP-адреса, но сервер отклоняет

У сервера есть проверка на занятость, но она может выполниться не правильно, тогда:
* GARP - Клиент отсылает ARP запрос о своем же собственном IP-адресе. Проверка на то, есть ли в сети устройство с таким IP-адресом. Если адрес не используется, то никем этот адрес не используется. 

Если произошла ситуация, что клиент получил ARP Reply, то клиент отсылает:
* Decline

Выше мы предположили ситуацию, когда клиент и сервер в одном подсети. И если мы расположим сервер за роутером, то до него не дойдет. 

Можем назначить DHCP сервер на Router, если трафика мало.

```IPAM``` - IP Address Management. Появляется центральная точка, которая позволяет управлять адресным пространством. DHCP сервера нужно связать с серверами IPAM.

## DHCP Relay

На роутере настраиваем Relay. Указываем адреса DHCP серверов. 

<p style="text-align: left"><img src=res/8_3.png width="500px"/></p>