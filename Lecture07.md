# Транспортный уровень

## UDP (User Datagram Protocol)

UDP, или Протокол дейтаграмм пользователя, — это легковесный протокол, который предлагает способ отправки сообщений (или дейтаграмм) без установления соединения и практически без накладных расходов. 

### Характеристики UDP

- Быстрый и эффективный: За счёт отказа от установления соединений и контроля потока UDP быстрее, чем альтернативы, вроде TCP.
- Без гарантии доставки: Протокол не гарантирует, что пакеты достигнут своего получателя, и не предоставляет коррекции ошибок.
- Идеально для времени критичных приложений: Подходит для приложений, которые могут пожертвовать надёжностью ради скорости, например, потоковая передача аудио и видео, онлайн-игры.

### Структура Заголовка UDP Сегмента

<p style="text-align: left"><img src=res/7_0.png width="800px"/></p>

Заголовок UDP прост и состоит из нескольких ключевых полей:

1. Source Port (Порт отправителя):
  - Этот порт идентифицирует отправляющее приложение на устройстве-источнике. Обычно выбирается рандомным, не занятым. С произвольного порта устанавливаем соединение.

2. Destination Port (Порт получателя):
  - Определяет приложение на устройстве-получателе, которому предназначена дейтаграмма.

3. Length (Длина):
  - Указывает общую длину дейтаграммы UDP (заголовок плюс данные).

4. Checksum (Контрольная сумма):
  - Используется для проверки целостности данных в сегменте.

5. Data (Данные):
  - Непосредственно полезная нагрузка или данные, которые передаются.

### Порт

Порт — это числовой идентификатор, используемый для адресации конкретных приложений или процессов на устройствах в сети. Порты играют важную роль в сетевом взаимодействии, помогая направлять данные правильно.

- Диапазон портов простирается от 1 до 65535, разделяясь на отдельные категории в зависимости от их назначения и использования.

#### Классификация Портов

1. Well-Known Ports (Известные порты)
  - Диапазон: От 1 до 1023
  - Описание: Эти порты зарезервированы для использования общепризнанными сервисами и протоколами. Они фиксированы и стандартизированы.
  - Например: DNS-серверы используют порт 53; HTTP – порт 80; HTTPS – порт 443.

2. Registered Ports (Зарегистрированные порты)
  - Диапазон: От 1024 до 49151
  - Описание: Эти порты могут быть зарегистрированы для использования определёнными приложениями или сервисами. Многие приложения используют эти порты, но они не столь строго зарезервированы, как well-known ports.

3. Dynamic or Private Ports (Динамические или частные порты)
  - Диапазон: От 49152 до 65535
  - Описание: Эти порты предназначены для временного или частного использования. Обычно они назначаются динамически клиентскими приложениями во время сетевых взаимодействий.

**!!! Порт может быть привязан ТОЛЬКО к одному процессу !!!** 

### Сокет

Это пара: IP + Port. Идентифицирует процесс глобально. 



## ICMP (Internet Control Message Protocol)

ICMP, или Протокол управляющих сообщений Интернета, — это служебный и вспомогательный протокол, который играет критически важную роль в работе сетевой инфраструктуры. Несмотря на то, что ICMP не предназначен для передачи пользовательских данных, его значение трудно переоценить.

### Основные Функции ICMP

- Диагностика сети: Используется для обмена сообщениями, позволяющими определить состояние сети, например, с помощью утилиты ping.
- Сообщения об ошибках: Регистрирует и сообщает об ошибках маршрутизации или недоступности хостов, например, в случае, если узел не отвечает.
- Управление и контроль потока: Помогает управлять потоком данных, предупреждая отправителя о необходимости уменьшить скорость передачи данных через сеть.

### Структура Заголовка ICMP

<p style="text-align: left"><img src=res/7_7.png width="800px"/></p>

Заголовок ICMP-сообщения включает в себя несколько ключевых полей:

1. Type (Тип)
  - Определяет тип ICMP-сообщения, например, запрашиваемое или ответное сообщение ping.

2. Code (Код)
  - Уточняет подтип ICMP-сообщения, давая более детальную информацию о характере сообщения.

3. Checksum (Контрольная сумма)
  - Используется для проверки целостности данных ICMP-сообщения, гарантируя, что данные не были изменены в пути.


### Path MTU Discovery

Path MTU Discovery — это процесс для определения максимального размера пакета (MTU), который можно передать по сети без фрагментации.

#### Основные Функции

- Избежание Фрагментации: Предотвращает разделение пакетов на меньшие фрагменты, что улучшает производительность сети.
- Оптимизация Передачи: Определение оптимального размера пакетов снижает потери и задержки.

#### Механизм Работы

1. Отправка Пакетов с Флагом DF: Пакеты посылаются с флагом Don't Fragment.
2. Получение ICMP Сообщений: Если пакет слишком большой, промежуточное устройство возвращает ICMP сообщение о необходимости фрагментации.
3. Регулировка Размеров: Отправитель уменьшает пакет и повторяет отправку до успешной передачи.

### TTL Exceeded

TTL Exceeded — это сообщение об ошибке, которое возникает при истечении времени "жизни" пакета в сети. Это часть протокола ICMP и служит важным средством для диагностики сетевых маршрутов.

#### Что Такое TTL?

- TTL (Time to Live): Это поле в заголовке IP-пакета, которое ограничивает количество узлов (hop), через которые может пройти пакет. Изначально TTL устанавливается отправителем.

#### Как Работает TTL Exceeded?

1. Каждый Узел Уменьшает TTL: С каждым пройденным маршрутизатором значение TTL уменьшается на 1.
2. Истечение TTL: Если TTL достигает 0 до того, как пакет достигает своего назначения, маршрутизатор, снижающий TTL до 0, отбрасывает пакет.
3. Генерация Сообщения ICMP: Маршрутизатор отправляет обратно отправителю сообщение ICMP "TTL Exceeded in Transit", уведомляя о невозможности доставки пакета.

#### Зачем Это Нужно?

- Диагностика Сети: Помогает в инструментах вроде ```traceroute```, которые используют TTL для определения маршрута до назначения.
- Предотвращение Зацикливания: Защищает сеть от бесконечно раундирующих пакетов в случае ошибки маршрутизации.



## TCP (Transmission Control Protocol)

Главный протокол. Протокол позволяет управлять передачей: регулировать скорость, возможность гарантировать доставку.

Изобразим заголовок TCP сегмента (4-х байтными словами):

<p style="text-align: left"><img src=res/7_1.png width="800px"/></p>

* SN - Номер первого байта в нашем сегменте
* ACK - Номер подтверждения, до какого момента данные были получены. С какого байта ожидаем следующие данные
* DataOffset - Откуда начинаются данные (TCP заголовок может иметь переменную длину)
* Битовые флаги:
    * URG - Важность, передаются ли важные данные
    * ACK - нужно ли обращать на ACK Number
    * PSH - Принятые данные нужно как можно быстрее передать приложению и не хранить в буфере
    * RST - Завершение соединения
    * SYN - Теперь SN имеет значение (только в момент установления соединения)

Как происходи соединение в TCP?

## Классический TCP

Протокол ориентированный на установлении соединения. Должны сначала установить соединение и только потом передавать данные. 

Тройное рукопожатие установления соединения:

* (A -> B) Сперва отсылаем сегмент с выставленным флагом ```SYN``` (Посмотри на поле SN и запомни мои номера, я начинаю передачу отсюда) 
* (B -> A) ```SYN``` и ```ACK``` (Посмотри на мою последовательность, я буду нумеровать данные так. Посмотри на поле ACK, указание на номер байта, который B ожидает получить, до этого момента точно все получено)
* (A -> B) Выставленный флаг ```ACK``` (Я увидел твой SN, понял, что у тебя отсчет с такого номера)

<p style="text-align: left"><img src=res/7_2.png width="400px"/></p>

!!! Данные начинаются с n. Пусть данные разером d. Тогда отправляем ```n + d + 1```. Ожидаем данные с этого байта.

TCP соединение установилось, начинаем передавать данные.

### Скользящее окно

Данные делим на сегменты. Отправили ```n``` байт и ждем ответ ```n + 1```. И так далее. 

<p style="text-align: left"><img src=res/7_3.png width="500px"/></p>

Есть проблема простаивания канала. Ждем пока данные были получены и только потом продолжаем отправку. TCP предлагает скользящее окно. 

Давайте будем отправлять не по одному сегменту, а сразу несколько. Отправляем все то, что попало в окно и только потом ждем подтверждение. 

<p style="text-align: left"><img src=res/7_4.png width="500px"/></p>

Пока отправляем сегменты, нам может прийти подтверждение на ранее отправленные сегменты, тогда двигаем окно.

#### Сегмент потерялся

Предо=положим, что 3-ий сегмент потерялся. При отправке мы запускаем таймеры. Когда истекает таймер, если мы не получили ответ, то второй раз отправляем сегмент и запускаем таймер заново.

На принимающей стороне выделяется буфер в который эти сегменты складываем: 

<p style="text-align: left"><img src=res/7_5.png width="500px"/></p>

!!! 3 для простоты понимания, на самом деле это номера байтов.

Не может подтвердить дальше, пока есть разрыв.


TCP двунаправленный протокол. Сторона говорит соседу, какой размер окна использовать. Сторона может сама решить, какое окно использовать, но ```только меньше``` (У стороны B может быть терабайтная скорость, а у A только мегабайтная, тогда A устанавливает маленькое окно).

Сторона B может выставить ```нулевой размер окна``` - это значит, стоп, мне нужно обработать данные. 

Если данные успешно передаются, то окно увеличивается, в случае разрыва оно сбрасывается, тогда мы можем видеть следующий график ```пила``` (**TCP Slow Start**)

<p style="text-align: left"><img src=res/7_6.png width="500px"/></p>


## Способы оптимизации

* Задержанное подтверждение (Delay ACK). Принимающая сторона, если нет пользовательских данных для отправки, какое-то время будет задерживать отправку пустых сегментов только для подтверждения. Если данные для отправки есть, то шлем данные и выставляем ACK.
* Алгоритм Нейгла - чуть-чуть задерживаем отправку данных, если данные маленькие. Подождем еще немного данных.


## Современный TCP

Как выбирается размер сегмента:

* В IP протоколе выставляем флаг DF (Do not Fragment), если пакет не пролез по MTU, то отсылаем ICMP сигнал. Уменьшаем размер сегмента
* Используем поле опций, а именно MSS (Max Segment Size). Роутер может вмешаться в четвертый уровень и изменить MSS значение

